{"version":3,"file":"static/chunks/pages/_error-3289ca9832462255.js","mappings":"4aACA,CAAAA,OAAAC,QAAA,CAAAD,OAAAC,QAAA,MAAAC,IAAA,EACA,UACA,WACA,OAAeC,EAAQ,MACvB,EACA,8IC6XA,SAAAC,cAAAC,CAAA,EACA,IAAAC,EAAAC,OAAAC,MAAA,OAEA,IACAD,OAAAE,OAAA,CAAAJ,GAAAK,OAAA,GAAAC,EAAAC,EAAA,IACA,iBAAAA,GACAN,CAAAA,CAAA,CAAAK,EAAA,CAAAC,CAAA,CAEA,EACA,CAAI,MAAAC,EAAA,CACAC,EAAAC,CAAW,EACTC,EAAAC,EAAM,CAAAC,IAAA,kGACZ,CAEA,OAAAZ,CACA,CAsBA,SAAAa,yBAAAC,CAAA,EAGA,IAAAd,EAAAc,EAAAd,OAAA,KACAe,EAAAf,EAAAe,IAAA,cACAC,EAAAF,EAAAG,MAAA,IAAAA,MAAA,CAAAC,SAAA,gBACAC,EAAAL,EAAAM,GAAA,KACAC,EAAAF,EAAAG,UAAA,CAAAN,GAAAG,EAAA,GAA0EH,EAAS,KAAKD,EAAK,EAAEI,EAAY,EAI3GI,EAAA,EAAAC,IAAA,EAAAC,KAAAA,EAGAC,EAAA,EAAAA,OAAA,CAEA,MAAS,GAAAC,EAAAC,EAAA,EAAiB,CAC1BR,IAAAC,EACAQ,OAAAf,EAAAe,MAAA,CACAC,aAAAC,0BAAAZ,GACAnB,QAAAF,cAAAE,GACA0B,QAAAA,EACAH,KAAAA,CACA,EACA,CAGA,SAAAQ,0BAAAX,CAAA,EAEA,GAAAA,EAIA,IAGA,IAAAY,EAAA,IAAAC,IAAAb,EAAA,yBAAAc,MAAA,CAAAC,KAAA,IACA,OAAAH,EAAAI,MAAA,CAAAJ,EAAAP,KAAAA,CACA,CAAI,MAAAY,EAAA,CACJ,MACA,CACA,2BC1cA,SAAAC,gBAAAC,CAAA,EACA,IAAAC,EAEIC,EAAAC,UAAU,CAAAC,OAAAC,GAAA,6BAEdC,EACAL,GAAAA,EAAAM,GAAA,EAAAN,EAAAM,GAAA,GACAN,EAAAM,GAAA,GACA,GAEAD,GAAAA,EAAAE,SAAA,EACAF,EAAAE,SAAA,CAAAR,EAEA,gBCdA,eAAAS,yBACA,IACIC,EAAAxC,CAAW,EAAIC,EAAAC,EAAM,CAAAuC,GAAA,uBACzB,MAAU,GAAAC,EAAAC,EAAA,EAAK,KACXH,EAAAxC,CAAW,EAAIC,EAAAC,EAAM,CAAAuC,GAAA,wBACzB,CAAI,MAAA3C,EAAA,CACA0C,EAAAxC,CAAW,EAAIC,EAAAC,EAAM,CAAAuC,GAAA,kCAAA3C,EACzB,CACA,CCNA,eAAA8C,gCAAAC,CAAA,EACA,IAAUC,IAAAA,CAAA,CAAAC,IAAAA,CAAA,CAAAC,IAAAA,CAAA,EAAgBH,EAG1BI,EAAA,GAAAF,EAAAE,UAAA,EAAAJ,EAAAI,UAAA,CACA,GAAAA,GAAAA,EAAA,KAWA,CAAAJ,EAAAK,QAAA,CAVA,OAAAC,QAAAC,OAAA,GAcE,GAAAC,EAAAC,EAAA,EAASC,IACX,GAAAT,EAAA,CACA,IAAAU,EAAgCpD,yBAAwB0C,GACxDS,EAAAE,wBAAA,EAAuCD,kBAAAA,CAAA,EACvC,CAII,GAAAd,EAAAgB,EAAA,EAAgBV,GAAA,sCAA8CA,EAAI,IACtEW,UAAA,CACAC,KAAA,aACAC,QAAA,GACA/C,KAAA,CACAgD,SAAA,wBACA,CACA,CACA,EACA,GAEEjC,gBAAgBU,yBAClB,yBC9CA,IAAMwB,qBAAuBC,GACpB,GAAAC,EAAAC,GAAA,EAACC,IAAKA,CAAClB,WAAYe,EAAMf,UAAU,CAAEmB,sBAAoB,QAAQC,wBAAsB,uBAAuBC,0BAAwB,cAE/IP,CAAAA,qBAAqBQ,eAAe,CAAG,MAAMC,IAG3C,MAAMC,gCAAuCD,GAGtCL,IAAAA,eAAqB,CAACK,IAE/B,IAAAE,EAAeX,4CCbfY,EAAAC,OAAA,CAAAxF,EAAA","sources":["webpack://_N_E/?fa0a","webpack://_N_E/./node_modules/@sentry/core/build/esm/utils-hoist/requestdata.js","webpack://_N_E/./node_modules/@sentry/core/build/esm/utils-hoist/vercelWaitUntil.js","webpack://_N_E/./node_modules/@sentry/nextjs/build/esm/common/utils/responseEnd.js","webpack://_N_E/./node_modules/@sentry/nextjs/build/esm/common/pages-router-instrumentation/_error.js","webpack://_N_E/./pages/_error.jsx","webpack://_N_E/./node_modules/next/error.js","webpack://_N_E/<anon>"],"sourcesContent":["\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_error\",\n      function () {\n        return require(\"private-next-pages/_error.jsx\");\n      }\n    ]);\n    if(module.hot) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_error\"])\n      });\n    }\n  ","import { parseCookie } from './cookie.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { isString, isPlainObject } from './is.js';\nimport { logger } from './logger.js';\nimport { normalize } from './normalize.js';\nimport { dropUndefinedKeys } from './object.js';\nimport { truncate } from './string.js';\nimport { stripUrlQueryAndFragment } from './url.js';\nimport { ipHeaderNames, getClientIPAddress } from './vendor/getIpAddress.js';\n\nconst DEFAULT_INCLUDES = {\n  ip: false,\n  request: true,\n  user: true,\n};\nconst DEFAULT_REQUEST_INCLUDES = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];\nconst DEFAULT_USER_INCLUDES = ['id', 'username', 'email'];\n\n/**\n * Options deciding what parts of the request to use when enhancing an event\n */\n\n/**\n * Extracts a complete and parameterized path from the request object and uses it to construct transaction name.\n * If the parameterized transaction name cannot be extracted, we fall back to the raw URL.\n *\n * Additionally, this function determines and returns the transaction name source\n *\n * eg. GET /mountpoint/user/:id\n *\n * @param req A request object\n * @param options What to include in the transaction name (method, path, or a custom route name to be\n *                used instead of the request's route)\n *\n * @returns A tuple of the fully constructed transaction name [0] and its source [1] (can be either 'route' or 'url')\n * @deprecated This method will be removed in v9. It is not in use anymore.\n */\nfunction extractPathForTransaction(\n  req,\n  options = {},\n) {\n  const method = req.method && req.method.toUpperCase();\n\n  let path = '';\n  let source = 'url';\n\n  // Check to see if there's a parameterized route we can use (as there is in Express)\n  if (options.customRoute || req.route) {\n    path = options.customRoute || `${req.baseUrl || ''}${req.route && req.route.path}`;\n    source = 'route';\n  }\n\n  // Otherwise, just take the original URL\n  else if (req.originalUrl || req.url) {\n    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n  }\n\n  let name = '';\n  if (options.method && method) {\n    name += method;\n  }\n  if (options.method && options.path) {\n    name += ' ';\n  }\n  if (options.path && path) {\n    name += path;\n  }\n\n  return [name, source];\n}\n\nfunction extractUserData(\n  user\n\n,\n  keys,\n) {\n  const extractedUser = {};\n  const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;\n\n  attributes.forEach(key => {\n    if (user && key in user) {\n      extractedUser[key] = user[key];\n    }\n  });\n\n  return extractedUser;\n}\n\n/**\n * Normalize data from the request object, accounting for framework differences.\n *\n * @param req The request object from which to extract data\n * @param options.include An optional array of keys to include in the normalized data. Defaults to\n * DEFAULT_REQUEST_INCLUDES if not provided.\n * @param options.deps Injected, platform-specific dependencies\n * @returns An object containing normalized request data\n *\n * @deprecated Instead manually normalize the request data into a format that fits `addNormalizedRequestDataToEvent`.\n */\nfunction extractRequestData(\n  req,\n  options\n\n = {},\n) {\n  const { include = DEFAULT_REQUEST_INCLUDES } = options;\n  const requestData = {};\n\n  // headers:\n  //   node, express, koa, nextjs: req.headers\n  const headers = (req.headers || {})\n\n;\n  // method:\n  //   node, express, koa, nextjs: req.method\n  const method = req.method;\n  // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node, nextjs: req.headers.host\n  // Express 4 mistakenly strips off port number from req.host / req.hostname so we can't rely on them\n  // See: https://github.com/expressjs/express/issues/3047#issuecomment-236653223\n  // Also: https://github.com/getsentry/sentry-javascript/issues/1917\n  const host = headers.host || req.hostname || req.host || '<no host>';\n  // protocol:\n  //   node, nextjs: <n/a>\n  //   express, koa: req.protocol\n  const protocol = req.protocol === 'https' || (req.socket && req.socket.encrypted) ? 'https' : 'http';\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  const originalUrl = req.originalUrl || req.url || '';\n  // absolute url\n  const absoluteUrl = originalUrl.startsWith(protocol) ? originalUrl : `${protocol}://${host}${originalUrl}`;\n  include.forEach(key => {\n    switch (key) {\n      case 'headers': {\n        requestData.headers = headers;\n\n        // Remove the Cookie header in case cookie data should not be included in the event\n        if (!include.includes('cookies')) {\n          delete (requestData.headers ).cookie;\n        }\n\n        // Remove IP headers in case IP data should not be included in the event\n        if (!include.includes('ip')) {\n          ipHeaderNames.forEach(ipHeaderName => {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete (requestData.headers )[ipHeaderName];\n          });\n        }\n\n        break;\n      }\n      case 'method': {\n        requestData.method = method;\n        break;\n      }\n      case 'url': {\n        requestData.url = absoluteUrl;\n        break;\n      }\n      case 'cookies': {\n        // cookies:\n        //   node, express, koa: req.headers.cookie\n        //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies\n        requestData.cookies =\n          // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can\n          // come off in v8\n          req.cookies || (headers.cookie && parseCookie(headers.cookie)) || {};\n        break;\n      }\n      case 'query_string': {\n        // query string:\n        //   node: req.url (raw)\n        //   express, koa, nextjs: req.query\n        requestData.query_string = extractQueryParams(req);\n        break;\n      }\n      case 'data': {\n        if (method === 'GET' || method === 'HEAD') {\n          break;\n        }\n        // NOTE: As of v8, request is (unless a user sets this manually) ALWAYS a http request\n        // Which does not have a body by default\n        // However, in our http instrumentation, we patch the request to capture the body and store it on the\n        // request as `.body` anyhow\n        // In v9, we may update requestData to only work with plain http requests\n        // body data:\n        //   express, koa, nextjs: req.body\n        //\n        //   when using node by itself, you have to read the incoming stream(see\n        //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know\n        //   where they're going to store the final result, so they'll have to capture this data themselves\n        const body = req.body;\n        if (body !== undefined) {\n          const stringBody = isString(body)\n            ? body\n            : isPlainObject(body)\n              ? JSON.stringify(normalize(body))\n              : truncate(`${body}`, 1024);\n          if (stringBody) {\n            requestData.data = stringBody;\n          }\n        }\n        break;\n      }\n      default: {\n        if ({}.hasOwnProperty.call(req, key)) {\n          requestData[key] = (req )[key];\n        }\n      }\n    }\n  });\n\n  return requestData;\n}\n\n/**\n * Add already normalized request data to an event.\n * This mutates the passed in event.\n */\nfunction addNormalizedRequestDataToEvent(\n  event,\n  req,\n  // This is non-standard data that is not part of the regular HTTP request\n  additionalData,\n  options,\n) {\n  const include = {\n    ...DEFAULT_INCLUDES,\n    ...(options && options.include),\n  };\n\n  if (include.request) {\n    const includeRequest = Array.isArray(include.request) ? [...include.request] : [...DEFAULT_REQUEST_INCLUDES];\n    if (include.ip) {\n      includeRequest.push('ip');\n    }\n\n    const extractedRequestData = extractNormalizedRequestData(req, { include: includeRequest });\n\n    event.request = {\n      ...event.request,\n      ...extractedRequestData,\n    };\n  }\n\n  if (include.user) {\n    const extractedUser =\n      additionalData.user && isPlainObject(additionalData.user)\n        ? extractUserData(additionalData.user, include.user)\n        : {};\n\n    if (Object.keys(extractedUser).length) {\n      event.user = {\n        ...event.user,\n        ...extractedUser,\n      };\n    }\n  }\n\n  if (include.ip) {\n    const ip = (req.headers && getClientIPAddress(req.headers)) || additionalData.ipAddress;\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n}\n\n/**\n * Add data from the given request to the given event\n *\n * @param event The event to which the request data will be added\n * @param req Request object\n * @param options.include Flags to control what data is included\n * @param options.deps Injected platform-specific dependencies\n * @returns The mutated `Event` object\n *\n * @deprecated Use `addNormalizedRequestDataToEvent` instead.\n */\nfunction addRequestDataToEvent(\n  event,\n  req,\n  options,\n) {\n  const include = {\n    ...DEFAULT_INCLUDES,\n    ...(options && options.include),\n  };\n\n  if (include.request) {\n    const includeRequest = Array.isArray(include.request) ? [...include.request] : [...DEFAULT_REQUEST_INCLUDES];\n    if (include.ip) {\n      includeRequest.push('ip');\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const extractedRequestData = extractRequestData(req, { include: includeRequest });\n\n    event.request = {\n      ...event.request,\n      ...extractedRequestData,\n    };\n  }\n\n  if (include.user) {\n    const extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};\n\n    if (Object.keys(extractedUser).length) {\n      event.user = {\n        ...event.user,\n        ...extractedUser,\n      };\n    }\n  }\n\n  // client ip:\n  //   node, nextjs: req.socket.remoteAddress\n  //   express, koa: req.ip\n  //   It may also be sent by proxies as specified in X-Forwarded-For or similar headers\n  if (include.ip) {\n    const ip = (req.headers && getClientIPAddress(req.headers)) || req.ip || (req.socket && req.socket.remoteAddress);\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n\n  return event;\n}\n\nfunction extractQueryParams(req) {\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  let originalUrl = req.originalUrl || req.url || '';\n\n  if (!originalUrl) {\n    return;\n  }\n\n  // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n  // hostname on the beginning. Since the point here is just to grab the query string, it doesn't matter what we use.\n  if (originalUrl.startsWith('/')) {\n    originalUrl = `http://dogs.are.great${originalUrl}`;\n  }\n\n  try {\n    const queryParams = req.query || new URL(originalUrl).search.slice(1);\n    return queryParams.length ? queryParams : undefined;\n  } catch (e2) {\n    return undefined;\n  }\n}\n\n/**\n * Transforms a `Headers` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into a simple key-value dict.\n * The header keys will be lower case: e.g. A \"Content-Type\" header will be stored as \"content-type\".\n */\n// TODO(v8): Make this function return undefined when the extraction fails.\nfunction winterCGHeadersToDict(winterCGHeaders) {\n  const headers = {};\n  try {\n    winterCGHeaders.forEach((value, key) => {\n      if (typeof value === 'string') {\n        // We check that value is a string even though it might be redundant to make sure prototype pollution is not possible.\n        headers[key] = value;\n      }\n    });\n  } catch (e) {\n    DEBUG_BUILD &&\n      logger.warn('Sentry failed extracting headers from a request object. If you see this, please file an issue.');\n  }\n\n  return headers;\n}\n\n/**\n * Convert common request headers to a simple dictionary.\n */\nfunction headersToDict(reqHeaders) {\n  const headers = Object.create(null);\n\n  try {\n    Object.entries(reqHeaders).forEach(([key, value]) => {\n      if (typeof value === 'string') {\n        headers[key] = value;\n      }\n    });\n  } catch (e) {\n    DEBUG_BUILD &&\n      logger.warn('Sentry failed extracting headers from a request object. If you see this, please file an issue.');\n  }\n\n  return headers;\n}\n\n/**\n * Converts a `Request` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into the format that the `RequestData` integration understands.\n */\nfunction winterCGRequestToRequestData(req) {\n  const headers = winterCGHeadersToDict(req.headers);\n\n  return {\n    method: req.method,\n    url: req.url,\n    query_string: extractQueryParamsFromUrl(req.url),\n    headers,\n    // TODO: Can we extract body data from the request?\n  };\n}\n\n/**\n * Convert a HTTP request object to RequestEventData to be passed as normalizedRequest.\n * Instead of allowing `PolymorphicRequest` to be passed,\n * we want to be more specific and generally require a http.IncomingMessage-like object.\n */\nfunction httpRequestToRequestData(request\n\n) {\n  const headers = request.headers || {};\n  const host = headers.host || '<no host>';\n  const protocol = request.socket && (request.socket ).encrypted ? 'https' : 'http';\n  const originalUrl = request.url || '';\n  const absoluteUrl = originalUrl.startsWith(protocol) ? originalUrl : `${protocol}://${host}${originalUrl}`;\n\n  // This is non-standard, but may be sometimes set\n  // It may be overwritten later by our own body handling\n  const data = (request ).body || undefined;\n\n  // This is non-standard, but may be set on e.g. Next.js or Express requests\n  const cookies = (request ).cookies;\n\n  return dropUndefinedKeys({\n    url: absoluteUrl,\n    method: request.method,\n    query_string: extractQueryParamsFromUrl(originalUrl),\n    headers: headersToDict(headers),\n    cookies,\n    data,\n  });\n}\n\n/** Extract the query params from an URL. */\nfunction extractQueryParamsFromUrl(url) {\n  // url is path and query string\n  if (!url) {\n    return;\n  }\n\n  try {\n    // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n    // hostname as the base. Since the point here is just to grab the query string, it doesn't matter what we use.\n    const queryParams = new URL(url, 'http://dogs.are.great').search.slice(1);\n    return queryParams.length ? queryParams : undefined;\n  } catch (e3) {\n    return undefined;\n  }\n}\n\nfunction extractNormalizedRequestData(\n  normalizedRequest,\n  { include },\n) {\n  const includeKeys = include ? (Array.isArray(include) ? include : DEFAULT_REQUEST_INCLUDES) : [];\n\n  const requestData = {};\n  const headers = { ...normalizedRequest.headers };\n\n  if (includeKeys.includes('headers')) {\n    requestData.headers = headers;\n\n    // Remove the Cookie header in case cookie data should not be included in the event\n    if (!include.includes('cookies')) {\n      delete (headers ).cookie;\n    }\n\n    // Remove IP headers in case IP data should not be included in the event\n    if (!include.includes('ip')) {\n      ipHeaderNames.forEach(ipHeaderName => {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete (headers )[ipHeaderName];\n      });\n    }\n  }\n\n  if (includeKeys.includes('method')) {\n    requestData.method = normalizedRequest.method;\n  }\n\n  if (includeKeys.includes('url')) {\n    requestData.url = normalizedRequest.url;\n  }\n\n  if (includeKeys.includes('cookies')) {\n    const cookies = normalizedRequest.cookies || (headers && headers.cookie ? parseCookie(headers.cookie) : undefined);\n    requestData.cookies = cookies || {};\n  }\n\n  if (includeKeys.includes('query_string')) {\n    requestData.query_string = normalizedRequest.query_string;\n  }\n\n  if (includeKeys.includes('data')) {\n    requestData.data = normalizedRequest.data;\n  }\n\n  return requestData;\n}\n\nexport { DEFAULT_USER_INCLUDES, addNormalizedRequestDataToEvent, addRequestDataToEvent, extractPathForTransaction, extractQueryParamsFromUrl, extractRequestData, headersToDict, httpRequestToRequestData, winterCGHeadersToDict, winterCGRequestToRequestData };\n//# sourceMappingURL=requestdata.js.map\n","import { GLOBAL_OBJ } from './worldwide.js';\n\n/**\n * Function that delays closing of a Vercel lambda until the provided promise is resolved.\n *\n * Vendored from https://www.npmjs.com/package/@vercel/functions\n */\nfunction vercelWaitUntil(task) {\n  const vercelRequestContextGlobal =\n    // @ts-expect-error This is not typed\n    GLOBAL_OBJ[Symbol.for('@vercel/request-context')];\n\n  const ctx =\n    vercelRequestContextGlobal && vercelRequestContextGlobal.get && vercelRequestContextGlobal.get()\n      ? vercelRequestContextGlobal.get()\n      : {};\n\n  if (ctx && ctx.waitUntil) {\n    ctx.waitUntil(task);\n  }\n}\n\nexport { vercelWaitUntil };\n//# sourceMappingURL=vercelWaitUntil.js.map\n","import { logger, flush } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build.js';\n\n/**\n * Flushes pending Sentry events with a 2 second timeout and in a way that cannot create unhandled promise rejections.\n */\nasync function flushSafelyWithTimeout() {\n  try {\n    DEBUG_BUILD && logger.log('Flushing events...');\n    await flush(2000);\n    DEBUG_BUILD && logger.log('Done flushing events');\n  } catch (e) {\n    DEBUG_BUILD && logger.log('Error while flushing events:\\n', e);\n  }\n}\n\nexport { flushSafelyWithTimeout };\n//# sourceMappingURL=responseEnd.js.map\n","import { withScope, httpRequestToRequestData, captureException, vercelWaitUntil } from '@sentry/core';\nimport { flushSafelyWithTimeout } from '../utils/responseEnd.js';\n\n/**\n * Capture the exception passed by nextjs to the `_error` page, adding context data as appropriate.\n *\n * @param contextOrProps The data passed to either `getInitialProps` or `render` by nextjs\n */\nasync function captureUnderscoreErrorException(contextOrProps) {\n  const { req, res, err } = contextOrProps;\n\n  // 404s (and other 400-y friends) can trigger `_error`, but we don't want to send them to Sentry\n  const statusCode = (res && res.statusCode) || contextOrProps.statusCode;\n  if (statusCode && statusCode < 500) {\n    return Promise.resolve();\n  }\n\n  // In previous versions of the suggested `_error.js` page in which this function is meant to be used, there was a\n  // workaround for https://github.com/vercel/next.js/issues/8592 which involved an extra call to this function, in the\n  // custom error component's `render` method, just in case it hadn't been called by `getInitialProps`. Now that that\n  // issue has been fixed, the second call is unnecessary, but since it lives in user code rather than our code, users\n  // have to be the ones to get rid of it, and guaraneteedly, not all of them will. So, rather than capture the error\n  // twice, we just bail if we sense we're in that now-extraneous second call. (We can tell which function we're in\n  // because Nextjs passes `pathname` to `getInitialProps` but not to `render`.)\n  if (!contextOrProps.pathname) {\n    return Promise.resolve();\n  }\n\n  withScope(scope => {\n    if (req) {\n      const normalizedRequest = httpRequestToRequestData(req);\n      scope.setSDKProcessingMetadata({ normalizedRequest });\n    }\n\n    // If third-party libraries (or users themselves) throw something falsy, we want to capture it as a message (which\n    // is what passing a string to `captureException` will wind up doing)\n    captureException(err || `_error.js called with falsy error (${err})`, {\n      mechanism: {\n        type: 'instrument',\n        handled: false,\n        data: {\n          function: '_error.getInitialProps',\n        },\n      },\n    });\n  });\n\n  vercelWaitUntil(flushSafelyWithTimeout());\n}\n\nexport { captureUnderscoreErrorException };\n//# sourceMappingURL=_error.js.map\n","import * as Sentry from \"@sentry/nextjs\";\nimport Error from \"next/error\";\nconst CustomErrorComponent = props => {\n  return <Error statusCode={props.statusCode} data-sentry-element=\"Error\" data-sentry-component=\"CustomErrorComponent\" data-sentry-source-file=\"_error.jsx\" />;\n};\nCustomErrorComponent.getInitialProps = async contextData => {\n  // In case this is running in a serverless function, await this in order to give Sentry\n  // time to send the error before the lambda exits\n  await Sentry.captureUnderscoreErrorException(contextData);\n\n  // This will contain the status code of the response\n  return Error.getInitialProps(contextData);\n};\nexport default CustomErrorComponent;","module.exports = require('./dist/pages/_error')\n"],"names":["window","__NEXT_P","push","__webpack_require__","headersToDict","reqHeaders","headers","Object","create","entries","forEach","key","value","e","debug_build","X","utils_hoist_logger","kg","warn","httpRequestToRequestData","request","host","protocol","socket","encrypted","originalUrl","url","absoluteUrl","startsWith","data","body","undefined","cookies","object","Jr","method","query_string","extractQueryParamsFromUrl","queryParams","URL","search","slice","length","e3","vercelWaitUntil","task","vercelRequestContextGlobal","worldwide","GLOBAL_OBJ","Symbol","for","ctx","get","waitUntil","flushSafelyWithTimeout","common_debug_build","log","esm_exports","yl","captureUnderscoreErrorException","contextOrProps","req","res","err","statusCode","pathname","Promise","resolve","currentScopes","$e","scope","normalizedRequest","setSDKProcessingMetadata","Tb","mechanism","type","handled","function","CustomErrorComponent","props","jsx_runtime","jsx","Error","data-sentry-element","data-sentry-component","data-sentry-source-file","getInitialProps","contextData","Sentry","_error","module","exports"],"sourceRoot":""}